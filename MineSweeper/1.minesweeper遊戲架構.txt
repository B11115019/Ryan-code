1.執行方式:
{
	讀指令檔(fileIO)
	{
		格式: MineSweeper.exe CommandFile <輸入指令檔> <輸出檔>
	}
	
	cin, cout模式
	{
		MineSweeper.exe CommandInput
	}
}

2.遊戲操作:
點左鍵->打開方塊(是否為地雷)，擴散方塊。
點右鍵->插棋子，放問號。

3.遊戲面板(class: GameBoard)
{	
	生成盤面:
	{
		輸入列行及地雷數量(void setGameBoard)
		輸入列行及地雷生成機率(void setGameBoard)
		讀取盤面檔
		{
			<列><行>
			地雷面板:O表示無地雷，X表示地雷
		}
	}
	
	方格數字顯示
	格子為地雷或是空白
	
	操作後的格子為:
	無操作的格子->空白格
	點完左鍵->打開空白格
	點右鍵(一般空白格)->插旗子，
	點右鍵(棋子)->問號。
	點右鍵(問號)->回到空白格
}

4.輸贏判斷
{
	獲勝條件:
	全部空白格點開
	
	失敗條件:
	踩到地雷
	
	當遊戲結束時，輸出You win/lose the game
	切換遊戲狀態
}

5.遊戲狀態:
{
	待機狀態
	遊玩狀態
	遊戲結束狀態
}

6.執行指令(除了Print指令外，其餘指令需印出該指令是否執行成功):
{
	Load(待機狀態使用)
	{
		Load BoardFile <盤面檔相對路徑>OK
		Load RandomCount <M> <N> <炸彈數量>OK
		Load RandomRate <M> <N> <炸彈生成機率>OK
	}

	StartGame(待機狀態使用)	
	{
		成功載入盤面後，才可開始遊戲
		此指令執行後，進入遊玩狀態
		避免還沒載入盤面就開始執行遊戲
	}
	
	Print(所有狀態使用)
	{
		GameBoard:
			印出2D盤面，每個格子如下顯示
			未開啟的格子:#
			已開啟的空白格子:顯示周圍9宮格內的炸彈數量(0~8)
			標註棋子:f
			標註問號:?
			(Column與column之間有一個空白隔開)
		
		GameAnswer:
			印出2D盤面，每個格子如下顯示
			非地雷 : 則顯示周圍9宮格內的炸彈數量(0~8)
			地雷 : X
			(Column與column之間有一個空白隔開)
		
		GameState:
			印出現在遊戲狀態 : Standby/Playing/GameOver
		
		BombCount: 總炸彈數量
		FlagCount: 當前標註的總旗幟數量
		OpenBlankCount: 當前打開的空白格子數
		RemainBlankCount: 當前尚未打開的空白格子數

	}
	
	LeftClick(遊玩狀態)
	{
		格式:LeftClick <row> <col>
		避免開啟無法被開啟的格子(旗子)
		執行左右鍵指令時，輸入的座標超出範圍
	}
	
	RightClick(遊玩狀態)
	{
		RightClick <row> <col>
		避免標註無法被標註的格子(打開的空白格)
		執行左右鍵指令時，輸入的座標超出範圍
	}
	
	Replay(遊戲結束狀態)
	{
		重新開始遊戲
		切換遊戲狀態
	}
	
	Quit(遊戲結束狀態)
	{
		關閉程式
	}
	
	其他指令則為無效輸入
}

